---
layout: post
title: 5주차
---

## 이재웅 : 529 ~ 579 (2부 2.3.4절)

### 2.2.3 양쪽 연결고리 이상


- 양쪽 연결고리 모두에 인덱스가 없다면 어느 방향으로 처리하든 연결고리 이상 상태가 되어 억지로라도 Nested Loops 조인으로 연결을 시도한다면 엄청난 횟수의 전체테이블 스캔이 발생하게 됨.  


- 이러한 경우에 옵티마이져는 연결고리의 상태에 영향을 받지 않는 방식인 sort merge나 Hash 방식으로 실행계획을 수립.

```sql
    SELECT ....... 
     FROM TAB1 x, TAB2 y 
    WHERE y.KEY1 = x.KEY1 
      AND y.KEY2 between '200501' and '200503'; ---- (a)
```  

위의 예에서 TAB1과 TAB2는 1:M관계를 가진다. 만약 TAB2의 연결고리 인덱스가 KEY1+KEY2(결합인덱스) 순으로 되어 있다면 연결고리에는 이상이 없다. 그러나 KEY2+KEY1의 경우 처리할 양이 크게 증가.  
실전에서는 옵티마이져 모드나 통계정보에 따라 달라지기는 하겠지만 실제로 심각한 수행속도에 문제가 있는 SQL을 찾아보면 이러한 현상으로 인해 발생한 문제가 적지 않게 일어나고 있음.  
아래 SQL을 통해 여러개의 '=' 을 만들어 해결 가능.  
  
```sql
    SELECT ....... 
     FROM TAB1 x, TAB2 y 
    WHERE y.KEY1 = x.KEY1 
      AND y.KEY2 IN ('200501', '200502', '200503'); ---- (b)
```  

위의 (b)의 역할을 서브쿼리가 대신하게 하는 경우 연결고리 이상을 만들지 않을 수 있다. 그러나 서브쿼리로 인한 방법은 그리 간단하지 않음.  
서브쿼리의 경우 서브쿼리 문이 먼저 수행되어야 하는데 이러한 제약은 이미 TAB1과 TAB2 사이의 평등관계에 영향을 미치기 때문.  

```sql
    SELECT ....... 
     FROM TAB1 x, TAB2 y, TAB3 z
    WHERE x.KEY1 = y.KEY_Y 
      AND x.KEY2 = z.KEY_Z
	  AND x.KEY3 = '200506'
	  AND x.COL2 = '111';
```  

그림 2-2-12 참조)  
만약 M쪽인 TAB1이 먼저 수행된다면 TAB2나 TAB3에 상수값을 제공하므로 TAB2나 TAB3의 연결고리에는 문제가 없음.  
하지만 TAB2->TAB1->TAB3 순으로 연결된다면 KEY2에 상수값을 받지 못하므로 연결고리에 상처가 생김.  
관계가 없어도 조인이 불가능한 것은 아님. 관계가 없다는 말은 무조건이 조인 조건임을 의미하기 때문에 카티젼 곱의 결과가 나타남.  
또한 TAB2나 TAB3와 같은 테이블들은 데이터 양이 극히 적은 코드성 테이블인 경우가 많으므로 카티젼 곱이 두렵지 않을 수 있음.  
이러한 원리를 이용한 것이 스타(Star)조인.  
  
```sql
    SELECT ....... 
     FROM TAB3 x, TAB2 y, TAB1 z
    WHERE y.KEY1 = z.KEY1   ----- (a) 
      AND x.KEY1 = y.KEY1   ----- (b)
	  AND x.KEY2 = y.KEY2
	  AND x.COL1 = '200506'
	  AND z.COL2 = '111';
```  
  
그림 2-2-13 참조)  
(a)와 (b)에서처럼 SQL 문의 조건절에 어느 것을 사용해도 상관이 없을 것 같지만 실제로 그렇지 않음.  
설사 TAB1이 먼저 액세스 되어 z.KEY1이 상수값이 된다고 하더라도 아직 TAB3는 이를 상수값으로 제공 받을 수 없음.  
논리적으로는 동일한 값을 의미한다고 하더라도 조건절에 누구와 비교했느냐에 따라 상대적으로 연결고리 이상 상태가 발생할 수 있다.


## 2.3 조인 종류별 특징 및 활용방안
- 조인은 크게 두 가지로 나눌 수 있음. 한가지는 어떤 집합을 먼저 액세스 하여 상수값을 만들고 그것을 이용해 대응되는 집합을 찾아가는 것.  
- 다른 한가지는 서로 연결하기 좋도록 미리 소정의 선행작업을 수행한 다음 서로를 대응시켜 가는 방법.  
- 옵티마이져가 날이 갈수록 좋아지고 잇는 것은 사실이지만 필요하다면 옵티마이져의 잘못된 판단을 조정해 줄수 있어야 함.  
옵티마이져는 주어진 SQL하에서 최적화를 한다. SQL문에 문제가 있는 부분까지는 최적화 해주지 못함. 그러므로 조인을 이해해야 한다.  

### 2.3.1 Nested Loops 조인
- Nested Loops 조인은 가장 전통적인 방법이면서도 가장 보편적으로 사용되는 조인 방식.  
- 먼저 액세스한 결과를 다음의 액세스에 상수값으로 제공.  
- 처리절차 -> 그림 2-2-14참조. p537  

#### 가) Nested Loops 조인의 특성

1. 순차적으로 처리(순차적)
2. 선행하는 집합의 처리범위가 전체 일의 양을 결정(선행적)
3. 나중에 처리되는 테이블은 앞서 처리된 값을 받아 액세스(종속적)
4. 주로 랜덤액세스 방식으로 처리. 선행테이블의 인덱스를 액세스하는 방법은 첫 번째 로우만 랜덤 액세스. 연결작업은 모두 랜덤 액세스(랜덤 액세스)
5. 주어진 조건에 있는 모든 컬럼들이 인덱스를 가지고 있더라도 모두가 사용되는 것은 아님(선택적)
6. 연결고리가 되는 인덱스에 의해 연결작업이 수해되므로 연결고리 상태가 매우 중요(연결고리 상태, 방향성)
7. 부분범위 처리가 가능
8. 연결작업을 수행한 후 마지막으로 체크되는 조건은 경우에 따라서 수행속도에 미치는 영향이 달라짐(체크조건의 영향력)

#### 나) Nested Loops 조인의 적용기준
1. 부분범위 처리를 하는 경우 유리
2. 조인되는 어느 한쪽이 상대방 테이블에서 제공한 결과를 받아야지만 처리범위를 줄일 수 있는 상황일때 선택
3. 주로 처리량이 적은 경우(많더라도 부붐범위처리가 가능한 경우)라면 대개 이 조인방식이 가장 무난
4. 연결고리 상태에 따라 매우 큰 차이 발생. 인덱스를 구성할 때 이러한 부분이 적절하게 감안된 전략을 수립.
5. 먼저 수행한 집합의 처리범위의 크기와 얼마나 많은 처리 범위를 미리 줄여 줄 수 있느냐가 수행속도에 많은 영향을 미침.
6. 부분범위처리를 하는 경우에는 운반단위의 크기가 수행속도에 상당한 영향을 미침. 운반단위가 적을수록 빨리 채울 수 있으나 패치(fetch)횟수에서는 불리해짐.
7. 선행 테이블의 처리 범위가 많거나 연결 테이블의 랜덤 액세스의 양이 아주 많다면 Sort Merge조인이나 해쉬조인을 검토. 그러나 이러한 방법은 메모리 사용을 과도하게 요구 하므로 종합적 판단 필요. 

### 2.3.1.2 Nested Loops 조인의 순서 결정  
 - 가장 큰 영향을 미치는 것은 최초의 수행되는 선행집합.  
 - 연결고리 상태에 따라 발생하는 현상에 대해 살펴볼 때 나타났듯이 연결고리의 상태가 정상이라면 어느 방향으로 진행하든 대가는 동일.
 - 어느 쪽이 보다 초기에 많은 범위를 줄여줄 수 있는지를 따져보는 것이 필요. 
 - 어떤 컬럼이 액세스 의 조건이 되기 위해서는 반드시 비교되는 값이 '상수값'이어야 함. 방적식의 원리와 동일.

p542 참조)
- 액세스 순서에 따라 처리범위가 크게 달라짐.  
- 하지만 어떤 액세스 유형이 가장 빠를 것이라고 절대 단정지을 수 없음.  
- 해당 조건을 액세스하기 위한 수단(인덱스, 클러스터 등)이 어떻게 구성되어 있느냐에 따라 실제로 처리해야하는 일량은 전해 달라질 수 있음.  
- 옵티마이져는 주어진 환경하에서 최적의 경로를 찾아줄 뿐임. 우리가 정의한 환경에 문제가 있다면 아무리 훌륭한 옵티마이져라도 좋은 액세스를 찾아줄 수 없음.
- 조인의 순서에 매우 중요한 영향을 미치는 또 하나의 요소는 조인의 성공률.
- 두 개의 집합을 조인할 때는 보다 많은 처리범위를 줄여주는 집합이 선행되는 것만 중요하지만 세 개 이상의 테이블을 조인할 때는 각 조인 단계의 성공률은 다음 단계의 조인량을 결정.

p547 참조)  
인덱스를 스캔한 개수보다 테이블을 액세스한 숫자가 적다는 것은 인덱스 내부에서 체크하여 걸러진 것. 비효율 발생.  
결론적으로 조인에 최종적으로 성공한 건 124개. DEPT에 부여한 LOCATION으로 인한 것.  


- 논리적으로 가장 이상적인 처리방법은 가장 많은 데이터를 가진 테이블을 가장 먼저 최소의 범위로 만드는 일.    
- 하지만 실적에서는 이러한 판단을 내리는 것이 쉽지 않음. 복잡한 조인문인 경우 실행 계획도 길고 SQL도 복잡함. 이론적 배경을 바탕으로 많은 경우 대한 훈련이 필요.
- 지금까지 처리된 집합의 결과를 조인하고자 하는 집합에 결과를 제공했을 때 그것을 받는 것이 훨씬 유리하다면 Nested Loops, 그렇지 않으면 Sort Merge나 해쉬조인으로 해당 조인을 유도.
- 최적의 처리 경로를 알고 있어도 실행계획을 그렇게 나타나도록 유도하는 것은 쉽지 않음.
- 적절한 힌트를 잘 조합하거나, 인라인뷰를 이용하거나, 특정 컬럼의 인덱스 사용 억제(Suppressing)을 활용. 그렇도 안되면 ROWNUM을 삽입하여 특정 인라인뷰가 먼저 수행되도록 조정.

### 2.3.2 Sort Merge 조인

- 조인할 집합의 대응되는 대상은 서로 알 수 없는 임의의 장소이 위치할 때 이를 연결 가능하게 하는 방법은 서로 사전 작업을 통해 연결할 수 있는 모습으로 다시 배치하는 것.
- 재배치를 정렬(Sort) 방식으로 하여, 이들을 서로 연결(Merge)하는 방식이 Sort Merge.  

p554. 그림 2-2-16 참조)  
각 테이블에 범위 좁혀서 Sort해놓은 뒤 Merge.  
머지랑 정렬된 양쪽 값을 서로 비교하며 스캔해 내려가다가 다른 쪽 값이 비교할 값보다 커지면 멈추고, 그 커진 값과 반대편 값을 비교하여 다시 내려가는 방식.  
이 방식은 정렬해 둔 결과를 스캔하면서 연결되므로 연결작업에는 랜덤 액세스가 일어나지 않음.  
사용된 인덱스를 살펴보면 TAB1은 FLD1인덱스만 사용되었고, TAB2는 COL1인덱스만 사용. 연결고리인 KEY1, KEY2의 인덱스는 전혀 사용되지 않고 머지의 조건으로만 사용됨.  

#### 가) Sort Merge 조인의 특성
1. 동시적으로 처리됨. 양쪽 집합이 모두 준비완료 되어야만 머지를 시작할 수 있으므로 순차적인 처리가 불가능(동시적)
2. 각 집합이 준비작업을 할 때 다른 집합에서 처리한 결과를 제공받지 않음(독립적)
3. 정렬 준비가 완료된 후에라야 조인을 시작. 부분범위처리를 할 수 없어 항상 전체범위처리(전체범위처리)
4. 주로 스캔방식으로 처리. 처리범위를 줄이기 위해 인덱스를 사용하는 경우만 랜덤 액세스 발생(스캔방식)
5. 연결고리가 되는 컬럼은 인덱스를 전혀 사용하지 않음(선택적)
6. 조인의 방향과는 거의 무관(무방향성)
7. 스스로 자신의 처리범위를 줄이기 위해 사용되는 인덱스는 대개 가장 유리한 한 가지만 사용. 그 외의 조건들은 머지할 작업대상을 줄요주므로 중요

#### 나) Sort Merge 조인의 적용기준
1. 어차피 전체범위 처리를 할 수 밖에 없는 프로세싱에 검토
2. 상대방 테이블에서 어떤 상수값을 받지 않고서도 충분히 처리범위를 줄일 수 있다면 상당한 효과 기대
3. 주로 처리량이 많으면서 항상 전체범위 처리를 해야하는 경우에 유리
4. 연결고리 이상 상태에 영향을 받지 않으므로 연결고리를 위한 인덱스를 생성할 필요가 없을 때 매우 유용
5. 스스로 자신의 처리범위를 어떻게 줄일 수 있느냐가 수행속도에 많은 영향을 미치므로 효율적인 인덱스 구성이 중요
6. 전체범위처리를 하므로 운반단위의 크기가 수행속도에 영향을 미치지 않음.
7. 처리할 데이터 량이 적은 오란인 애플리케이션에서는 Nested Loops 조인이 더 유리
8. 옵티마이져 목표가 ALL_ROWS 인 경우 자주 Sort Merge 조인이나 해쉬조인으로 실행계획이 수립. 옵티마이져 목표에 주의.
9. 충분한 메모리 활용이 가능하고, 병렬처리를 통해 빠르게 정렬작업을 할 수 있다면 대량의 데이터 조인에 매우 유용.

### 2.3.3 Nested Loops 조인과 Sort Merge 조인의 비교
p559 참조)  
조건이 삭제되었을때 Nested Loops는 순차적으로 처리되므로 영향을 크게 받지 않으나, Sort Merge는 TAB2에 FULL SCAN이 일어남.  
뿐만 아니라 부담이 되는 정렬의 범위가 크게 늘어났고, 머지할 양도 크게 증가.  
이처럼 상황에 따라 조인 방식이 커다란 차이를 가져올 수 있음.

p561~562 참조)  
상수 조건 없어지고, order by 추가된 상황. Nested Loops는 상수를 받을 수 없으므로 FULL TABLE SCAN 발생 후 단계적으로 수행됨.  
Sort Merge 조인은 각각의 테이블마다 스캔 후 머지가 일어나므로 대량의 랜덤 액세스를 피할 수 있으므로 유리함.

### 2.3.4 해쉬(Hash) 조인
- 주로 소량의 특정 범위를 조인하는 용도로 활용하는 Nested Loops 조인은 처리범위만 지나치게 넓지 않다면 간단한 방법만으로 충분히 해결가능.
- 대량의 범위를 처리할 때는 상황이 어려움. Sort Merge 방식으로도 해결이 어려운 경우 시스템에 중대한 문제가 될 수 있음.
- 데이터 처리 범위가 초대향으로 증가하면서 Sort Merge가 더이상의 대안이 될 수 없는 지경에 이르렀음.
- 해쉬 조인은 연결행위마다 인덱스를 경유하여 랜덤을 하지 않고 해쉬 함수를 이용한 연결을 한다는 점과 파티션 단위로 처리하기 때문에 대량의 처리에도 수행속도가 급격히 상승하지 않는다.

#### ▷해쉬 영역(Hash Area)
- 해쉬 영역이란 해쉬 조인을 수행하기 위해 메모리 내에 만들어진 영역.  
- 해쉬 테이블에는 파티션들의 위치정보(Address)를 가지고 있으며 조인의 연결 작업을 수행할 때나 디스크에 내려가 있는 파티션 짝들을 찾는데 사용.

#### ▷파티션(Partition)
- 파티션이란 파티션을 결정하기 위해 수행하는 첫 번째 해쉬함수가 리턴한 동일한 해쉬값을 갖는 묶음.
- 동일한 해쉬값을 가진 로우들의 버켓(Bucket)
- 파티션 수를 많게 하면 적은 크기의 많은 파티션이 생성되기 때문에 비효율적인 I/O 발생할 수 있음.
- 반대로 너무 적게 하면 지나치게 큰 파티션이 생성되어 해쉬영역과 맞지 않을 수도 있음.

#### ▷클러스터(Cluster)
- 파티션은 작지않은 크기로 되어 있기 때문에 이를 다시 클러스터 단위로 분할.
- 클러스터는 연속된 블록으로 되어 있으며 디스크와 I/O하는 단위.
- 클러스터를 슬롯(Slot)이라고도 부르며, 마치 캐비닛을 파티션이라고 한다면 슬롯은 서랍에 비유가능.

#### ▷빌드 입력(Build Input)과 검색 입력(Probe Input)
- 조인을 위해 먼저 액세스하여 필요한 준비를 해두는 처리를 빌드입력.
- 나중에 액세스 하면서 조인을 수행하는 처리를 검증 혹은 검색입력.

#### ▷인-메모리(In-memory)해쉬조인과 유예 해쉬조인
- 빌드입력이 해쉬 영역에 모두 위치할 수 있는 경우는 인-메모리 해쉬 조인을 수행.
- 그렇지 못한 경우 유예 해쉬조인 수행.

#### ▷비트맵 벡터(Bitmap Vector)
- 빌드입력에 대해 파티션을 구하는 작업 중에 생성되며, 빌드 입력값들에 대한 유일한 값을 메모리 내의 해쉬 영역에 정의하는 것.
- 검색 입력의 파티션 생성 작업시에 필터링을 하는데 사용.

#### ▷해쉬 테이블(Hash Table)
- 이 테이블은 메모리 내에 만들어지며, 최종적으로 조인의 연결작업에서 대응되는 로우를 찾기 위한 해쉬 인덱스로 사용.
- 일반 인덱스에서 인덱스 컬럼값과 ROWID를 가지고 있는 것과 유사하게 해쉬 테이블은 해쉬키값과 해쉬 클러스터의 주소를 가지고 있음.

#### ▷파티션 테이블(Partition Table)
- 만약 빌드 입력이 메모리 크기를 초과하여 파티션을 생성하게 되면 파티션 테이블에 관련정보가 저장됨.

### 2.3.4.1 인-메모리 해쉬조인
- 인-메모리 해쉬조인은 빌드입력을 모두 메모리에 저장하고 해쉬 테이블을 만들어 검색 입력을 스캔하면서 조인을 수행
- 모양상으로는 랜덤이지만 거의 부담이 없는 랜덤을 수행하기 때문에 Sort Merge처럼 연결을 위해 정렬을 해야하거나 Nested Loops 처럼 수많은 블록을 액세스하지 않아도 되므로 대용량 데이터 조인에 매우 효과적.
- 특징은 조인의 연결을 위해서 기존에 미리 생성되어 있는 인덱스를 전혀 사용하지 않음.
- 조인 연결고리에 인덱스가 없어도 영향을 받지 않는다는 것과 그러면서도 오히려 기존의 B-Tree 인덱스 보다 더 유리한 해쉬를 이용한 조인을 할 수 있음.
- 다른 특징은 부분범위 처리가 가능.
- 그러나 메모리는 여러 프로세스들이 공동으로 사용하는 영역이라 크게 적용이 불가하므로 Nested Loop 조인으로 확실한 효율과 수행속도를 보장받을 수 있다면 지나치게 적용하지 않는 것이 좋음.

### 2.3.4.2 유예 해쉬조인
- 빌드입력이 해쉬영역을 초과하게 되면 어쩔 수 없이 디스크에 저장해야함.
- 빌드 입력의 일부라도 디스크에 저장할 수 밖에 없다면 정렬을 통해 연결을 하는 Sort Merge 조인처럼 정렬과 유사한 효과를 얻을 수 있는 방법이 해슁함수를 이용하는 방법.
- 해쉬영역을 초과하는 대용량의 데이터라 하더라도 해쉬함수를 이용하여 적절한 위치에 옮겨 두었다가 조인대상들을 다시 불러들여 해쉬 테이블을 통해 조인을 수행하므로 Sort Merge 조인이 갖는 최대의 약점인 대용량 데이터의 정렬에 대한 오버헤드를 해결.
- 선행 처리된 집합이 만든 비트맵 벡터를 이용하여 나중에 처리되는 집합을 조인 전에 미리 필터링을 할 수 있으므로 Nested Loops의 장점도 가짐.

## 민선유 : 580 ~ 634 (2부 2.3.8절)


# 2.3.5 세미(semi)조인

- 세미 조인이란 말 그대로 조인과 매우 유사한 데이터 연결 방법
- 서브쿼리를 사용했을 때 메인쿼리와의 연결 처리

## 세미 조인의 개념 및 특징 

- 주로 서브쿼리를 사용했을 때 메인쿼리와의 연결을 하기 위해 적용되는 광범위한 유사 조인을 의미
- 서브쿼리의 서브(Sub)는 말 그대로 '하위','부'를 뜻한다. 
- 서브쿼리는 메인(Main)이 되는 메인쿼리에 종속되는 하위의 쿼리이다.
- 별도의 정의를 하지 않아도 주영역의 모든 속성을 그대로 상속받을 수 있다.
- 당연히 주영역은 부영역의 속성을 이용할 수 없다. 
- 주영역에 하나 이상의 부영역이 있을 때 부영역간에는 서로의 속성을 공유할 수 없다. 
- `종속성` -> 조인과 다른 핵심적 차이 

**조인** -> 동등관계 (서로 위치를 다르게 해도 결과동일)
**서브쿼리** -> 종속관계 (교환법칙 성립 X)

P583 (그림 2-2-23) 참고 

**조인** -> 집합의 곱 
**서브쿼리** -> 결과 집합은 메인쿼리와 항상 동일 
                        -> 메인쿼리의 쿼리의 집합을 절대 변형하지 X  


Q. 서브쿼리와 메인쿼리 중에 어느것이 먼저 수행될까? 


## 세미조인의 실행계획 


### 1.  Nested Loops 형 세미조인 
- 가장 보편적인 형태 (Nested Loops 조인과 유사하게 동작)
- 어떤 집합이 먼저 수행되어 거기서 얻은 상수값을 연결 고리를 통하여 대응.
- 서브쿼리는 제공자 역할 / 확인자 역할 

`제공자` - 서브쿼리가 먼저 수행되어 list의 연결고리 값을 상수값으로 만들고 메인쿼리 연결고리에 대응시키는 방법 
`확인자` - 메인쿼리가 먼저 수행되어 상수값이 된 연결고리 값을 서브쿼리 연결고리에 제공하는 방법 

P586 (그림 2-2-24) 참고 
- 마치 조인처럼 Nested Loops 조인 
- 서브쿼리인 TAB2 먼저 수행하고 그 결과를 이용해 메인쿼리가 연결 
- SORT(UNIQUE) 조건 추가 
- 만약,  KEY2가 기본키라면 UNIQUE 만드는 처리는 생략 
- `제공자` 역할로 서브쿼리가 쓰임!
 
 
P587 (그림 2-2-25) 참고
- 서브쿼리 내에 메인쿼리의 컬럼이 존재 (논리적으로 먼저 수행 불가 X ) 
- 종속성 조건으로 메인쿼리 먼저 수행! 
- FILTER 조건으로 대응하는 첫 번째 까지만 연결 

Q. 잘못된 SQL 부분은? 

P589 참고 
```sql
UPDATE 청구 x
   SET 입금액 = nvl(입금액,0) + :int_amt
 WHERE 청구년월 = '200503'
   AND 고객번호 IN ( SELECT 고객번호
                     FROM   고객 y
                    WHERE  납입자 = :in_cust
                      AND    y.고객번호 = x.고객번호 ) ;
```
- 메인쿼리 먼저 수행 
- 고객번호 컬럼을 인덱스로 사용할 수 X 
- 메인쿼리 전체 풀스캔
- 메인쿼리가 성공한 집합건에 대해 서브쿼리 한번씩 수행 

-> A. 불필요한 조건을 삽입하여 발생한 문제 
-> B. 연결고리를 명확하게 정의하고 , 서브쿼리 내에 메인쿼리의 컬럼이 없어서 서브쿼리가 제공자 역할을 할 수 있도록 실행계획 수립 

### 2. Sort Merge형 세미조인 
- 연결고리에 이상이 발생하거나 대량의 데이터를 연결해야 할 때

P591 SQL 참고  
```sql 
SELECT .....
  FROM 사원
 WHERE 부서코드 IN ( SELECT 부서코드                                              
                     FROM   근태
                     WHERE  일자 BETWEEN '20050601' AND '20050612'
                     AND    근태유형 = '무단결근' )
   AND 직책 > '과장' ;
```

- 연결고리인 부서코드가 M:M 관계 
- 물론, Nested Loops 형으로도 처리될 수 있음 
- 서브쿼리는 메인쿼리와의 머지를 위해 SORT(UNIQUE) 처리 
- 독자적으로 처리범위를 충분히 출일 수 있을 때 효과적

### 3. Filter 형 세미조인 

- 확인자 역할 : 먼저 수행하여 액세스한 결과를 서브쿼리를 통해서 체크하여
취할 것인지, 아니면 버려야 할 것인지를 결정
- 효율적으로 수행하기 위해 버퍼(Buffer)내에 이전의 값을 저장해두었다가 대응되는 집합을 액세스하기 전에 먼저 저장된 값과 비교함으로써 액세스를 최소화하는 방법 

P593 SQL 참고 
``` sql 
SELECT --
  FROM  ORDER x
 WHERE  ORDER LIKE '200506%'
   AND  EXIST ( SELECT 'X'
                  FROM DEPT y
                 WHERE y.DEPTNO = x.SALDEPT ..... (a)
                   AND y.TYPE1 = '1' );
```
- 연결고리가 없음 
- EXISTS  를 사용한 세미조인은 언제나 확인자 역할만 가능하다. 

P594 
실행 계획을 보면 메인쿼리의 order 테이블은 3200 row 스캔, 
but, 서브쿼리의 DEPT 테이블은 10 회만 엑세스 . 

1) 먼저 ORDDATE_INDEX 에서 '200506%'를 만족하는 첫 번째 로우를 읽고 그 ROWID로 ORDER 테이블의 해당 로우를 액세스한다.
2) 그 로우가 가지고 있는 SALDEPT 와 버퍼에 있는 DEPT 와 비교한 결과가 같지 않으므로 DEPT 테이블의 기본키를 이용해 액세스한 후 TYPE='1'을 체크 한다. 체크를 하여 조건을만족하면 운반단위에 태우고 아니면 버린다.
3) 액세스한 DEPT 테이블의 비교 컬럼값들을 버퍼에 저장한다.
4) ORDERDATE_INDEX 의 두 번째 로우에 대한 ORDER 테이블 로우를 액세스한 후 버퍼와 체크한다. SALDEPT와 버퍼의 DEPT 비교 ( 버퍼는 하나의 값만 저장할 수 있으므로 앞서 저장된 값은 갱신된다. )
5)이와 같은 방법으로 ORDDATE_INDEX의 처리범위가 완료될 때까지 수행

GOOD : 버퍼를 이용한 처리를 하여 랜덤 액세스 양을 최소화
BAD : 극단적인 최악의 경우, 만약 SALDEPT가 매번 바뀌면 버퍼에 저장된 것과 항상 일치 X   - 버퍼를 사용한 이득을 전혀 느낄수 없음

# 2.3.6 스타(star) 조인 
- 기존의 조인방식들로 수행하면서 단지 조인의 실행계획이 특정한 절차로 수행되는 것 뿐
- 조인되는 집합들 간의 관계가 마치 별 모양처럼 생겼기 때문에 붙여짐 

P606 (그림 2-2-27) 참고 
- SALES 라는 매출정보 테이블 & 거기에 달려있는 각종 코드 테이블 간의 조인 

**문제점**
1. 조인이 일어나는 순간 다른 테이블은 지켜봄
2. 어느 것을 먼저 선택해서 조인해도 처리범위가 별로 줄어들지 않음
3. 결합인덱스를 구성하기 쉽지 않음 (사용자의 목적에 따라 어떤 조건이 부여될지 알 수 없으므로) 
4. 조인 결과 집합은 기존의 테이블이 아니므로 더이상 인덱스를 가질 수 X 

**해결방안 찾아가기**
->  SALES 테이블에 붙어있는 각각의 디멘전 테이블들 사이에는 특별한 릴레이션쉽이 없다. 
-> 연결고리의 조건이 없다는 것은 다른말로 무조건을 의미
-> 조건이 없다? -> 언제나 성공!

즉, 연결고리 조건이 없는 것이 아니라 언제나 연결이 성공한다! 

P610 (그림 2-2-28) 

- 디멘전 테이블 D1, D2, D3를 무조건 조건으로 조인하면 `카티젼 곱`으로 만들어짐 (2*3*2) 
- 논리적으로 FACT_T 와 CARTESIAN_T 가 동일한 의미 
- 일반적으로 디멘전 테이블은 소량으로 구성되기 때문에 카티젼 곱으로 만들어도 영향 X 

GOOD : 디멘전 테이블 때문에 여러번씩 조인하는것을 한번으로 크게 줄일 수 있다 .
BAD : 만약, 카티젼 곱은 숫자들이 크면 엄청나게 커짐...!

## 스타조인 실행계획
P611 참고
- 디멘전 테이블들이 먼저 카티젼 곱을 만들고, 그 결과를 팩트테이블과 조인
- 카티전 곱은 대부분 SortMerge 조인 형식 

카티젼 곱의 집합은 이미 인덱스를 가질 수 없고, 팩트 테이블은 디멘전 테이블들의 수많은 조합을 모두 감당할 인덱스를 미리 구성하기 어려우므로 인덱스를 사용하지 않는 해쉬조인이나 Sort Merge 조인으로 수행하는 것이 바람직한 방법! 


# 2.3.7 스타변형(Star Transformation) 조인 

- 스타조인의 단점을 일부 개선 
- 카티젼 곱 X -> `비트맵 인덱스`를 활용 

P75 비트맵 인덱스 그림 참고 
P618 SQL 참고 

- 각각을 먼저 'BITMAP AND'  연산 수행하고 테이블에 엑세스. 

Q. 그렇다면 서브쿼리를 통해 상수값을 제공받는 방식으로 처리되었을 때 SQL과 실행계획을 예상해 보자 

- 서브쿼리 테이블 엑세스하여 그 결과값으로 메인쿼리의 비트맥 인덱스를 액세스하여 임시 비트맵으로 비트맵 머지를 수행! 
- 서브쿼리 형태로 먼저 수행시켜 테이블의 범위를 줄이고 카티젼 곱을 만들지 않을 수 있도록 함!


GOOD : 각각의 서브쿼리로 범위를 줄이고, 이를 BITMAP AND 하여 팩트 테이블의 처리범위를 크게 줄였다고 하면 소량의 데이터와 남아있는 디멘전 테이블을 조인해도 부담이 없다. 
BAD : 서브쿼리로 팩트테이블의 범위를 크게 줄이지 못하면 효과 X
