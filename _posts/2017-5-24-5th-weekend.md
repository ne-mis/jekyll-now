---
layout: post
title: 5주차
---

## 이재웅 : 529 ~ 579 (2부 2.3.4절)

### 2.2.3 양쪽 연결고리 이상


- 양쪽 연결고리 모두에 인덱스가 없다면 어느 방향으로 처리하든 연결고리 이상 상태가 되어 억지로라도 Nested Loops 조인으로 연결을 시도한다면 엄청난 횟수의 전체테이블 스캔이 발생하게 됨.  


- 이러한 경우에 옵티마이져는 연결고리의 상태에 영향을 받지 않는 방식인 sort merge나 Hash 방식으로 실행계획을 수립.

```sql
    SELECT ....... 
     FROM TAB1 x, TAB2 y 
    WHERE y.KEY1 = x.KEY1 
      AND y.KEY2 between '200501' and '200503'; ---- (a)
```  

위의 예에서 TAB1과 TAB2는 1:M관계를 가진다. 만약 TAB2의 연결고리 인덱스가 KEY1+KEY2(결합인덱스) 순으로 되어 있다면 연결고리에는 이상이 없다. 그러나 KEY2+KEY1의 경우 처리할 양이 크게 증가.  
실전에서는 옵티마이져 모드나 통계정보에 따라 달라지기는 하겠지만 실제로 심각한 수행속도에 문제가 있는 SQL을 찾아보면 이러한 현상으로 인해 발생한 문제가 적지 않게 일어나고 있음.  
아래 SQL을 통해 여러개의 '=' 을 만들어 해결 가능.  
  
```sql
    SELECT ....... 
     FROM TAB1 x, TAB2 y 
    WHERE y.KEY1 = x.KEY1 
      AND y.KEY2 IN ('200501', '200502', '200503'); ---- (b)
```  

위의 (b)의 역할을 서브쿼리가 대신하게 하는 경우 연결고리 이상을 만들지 않을 수 있다. 그러나 서브쿼리로 인한 방법은 그리 간단하지 않음.  
서브쿼리의 경우 서브쿼리 문이 먼저 수행되어야 하는데 이러한 제약은 이미 TAB1과 TAB2 사이의 평등관계에 영향을 미치기 때문.  

```sql
    SELECT ....... 
     FROM TAB1 x, TAB2 y, TAB3 z
    WHERE x.KEY1 = y.KEY_Y 
      AND x.KEY2 = z.KEY_Z
	  AND x.KEY3 = '200506'
	  AND x.COL2 = '111';
```  

그림 2-2-12 참조)  
만약 M쪽인 TAB1이 먼저 수행된다면 TAB2나 TAB3에 상수값을 제공하므로 TAB2나 TAB3의 연결고리에는 문제가 없음.  
하지만 TAB2->TAB1->TAB3 순으로 연결된다면 KEY2에 상수값을 받지 못하므로 연결고리에 상처가 생김.  
관계가 없어도 조인이 불가능한 것은 아님. 관계가 없다는 말은 무조건이 조인 조건임을 의미하기 때문에 카티젼 곱의 결과가 나타남.  
또한 TAB2나 TAB3와 같은 테이블들은 데이터 양이 극히 적은 코드성 테이블인 경우가 많으므로 카티젼 곱이 두렵지 않을 수 있음.  
이러한 원리를 이용한 것이 스타(Star)조인.  
  
```sql
    SELECT ....... 
     FROM TAB3 x, TAB2 y, TAB1 z
    WHERE y.KEY1 = z.KEY1   ----- (a) 
      AND x.KEY1 = y.KEY1   ----- (b)
	  AND x.KEY2 = y.KEY2
	  AND x.COL1 = '200506'
	  AND z.COL2 = '111';
```  
  
그림 2-2-13 참조)  
(a)와 (b)에서처럼 SQL 문의 조건절에 어느 것을 사용해도 상관이 없을 것 같지만 실제로 그렇지 않음.  
설사 TAB1이 먼저 액세스 되어 z.KEY1이 상수값이 된다고 하더라도 아직 TAB3는 이를 상수값으로 제공 받을 수 없음.  
논리적으로는 동일한 값을 의미한다고 하더라도 조건절에 누구와 비교했느냐에 따라 상대적으로 연결고리 이상 상태가 발생할 수 있다.


## 2.3 조인 종류별 특징 및 활용방안
- 조인은 크게 두 가지로 나눌 수 있음. 한가지는 어떤 집합을 먼저 액세스 하여 상수값을 만들고 그것을 이용해 대응되는 집합을 찾아가는 것.  
- 다른 한가지는 서로 연결하기 좋도록 미리 소정의 선행작업을 수행한 다음 서로를 대응시켜 가는 방법.  
- 옵티마이져가 날이 갈수록 좋아지고 잇는 것은 사실이지만 필요하다면 옵티마이져의 잘못된 판단을 조정해 줄수 있어야 함.  
옵티마이져는 주어진 SQL하에서 최적화를 한다. SQL문에 문제가 있는 부분까지는 최적화 해주지 못함. 그러므로 조인을 이해해야 한다.  

### 2.3.1 Nested Loops 조인
- Nested Loops 조인은 가장 전통적인 방법이면서도 가장 보편적으로 사용되는 조인 방식.  
- 먼저 액세스한 결과를 다음의 액세스에 상수값으로 제공.  
- 처리절차 -> 그림 2-2-14참조. p537  

#### 가) Nested Loops 조인의 특성

1. 순차적으로 처리(순차적)
2. 선행하는 집합의 처리범위가 전체 일의 양을 결정(선행적)
3. 나중에 처리되는 테이블은 앞서 처리된 값을 받아 액세스(종속적)
4. 주로 랜덤액세스 방식으로 처리. 선행테이블의 인덱스를 액세스하는 방법은 첫 번째 로우만 랜덤 액세스. 연결작업은 모두 랜덤 액세스(랜덤 액세스)
5. 주어진 조건에 있는 모든 컬럼들이 인덱스를 가지고 있더라도 모두가 사용되는 것은 아님(선택적)
6. 연결고리가 되는 인덱스에 의해 연결작업이 수해되므로 연결고리 상태가 매우 중요(연결고리 상태, 방향성)
7. 부분범위 처리가 가능
8. 연결작업을 수행한 후 마지막으로 체크되는 조건은 경우에 따라서 수행속도에 미치는 영향이 달라짐(체크조건의 영향력)

#### 나) Nested Loops 조인의 적용기준
1. 부분범위 처리를 하는 경우 유리
2. 조인되는 어느 한쪽이 상대방 테이블에서 제공한 결과를 받아야지만 처리범위를 줄일 수 있는 상황일때 선택
3. 주로 처리량이 적은 경우(많더라도 부붐범위처리가 가능한 경우)라면 대개 이 조인방식이 가장 무난
4. 연결고리 상태에 따라 매우 큰 차이 발생. 인덱스를 구성할 때 이러한 부분이 적절하게 감안된 전략을 수립.
5. 먼저 수행한 집합의 처리범위의 크기와 얼마나 많은 처리 범위를 미리 줄여 줄 수 있느냐가 수행속도에 많은 영향을 미침.
6. 부분범위처리를 하는 경우에는 운반단위의 크기가 수행속도에 상당한 영향을 미침. 운반단위가 적을수록 빨리 채울 수 있으나 패치(fetch)횟수에서는 불리해짐.
7. 선행 테이블의 처리 범위가 많거나 연결 테이블의 랜덤 액세스의 양이 아주 많다면 Sort Merge조인이나 해쉬조인을 검토. 그러나 이러한 방법은 메모리 사용을 과도하게 요구 하므로 종합적 판단 필요. 

### 2.3.1.2 Nested Loops 조인의 순서 결정  
 - 가장 큰 영향을 미치는 것은 최초의 수행되는 선행집합.  
 - 연결고리 상태에 따라 발생하는 현상에 대해 살펴볼 때 나타났듯이 연결고리의 상태가 정상이라면 어느 방향으로 진행하든 대가는 동일.
 - 어느 쪽이 보다 초기에 많은 범위를 줄여줄 수 있는지를 따져보는 것이 필요. 
 - 어떤 컬럼이 액세스 의 조건이 되기 위해서는 반드시 비교되는 값이 '상수값'이어야 함. 방적식의 원리와 동일.

p542 참조)
- 액세스 순서에 따라 처리범위가 크게 달라짐.  
- 하지만 어떤 액세스 유형이 가장 빠를 것이라고 절대 단정지을 수 없음.  
- 해당 조건을 액세스하기 위한 수단(인덱스, 클러스터 등)이 어떻게 구성되어 있느냐에 따라 실제로 처리해야하는 일량은 전해 달라질 수 있음.  
- 옵티마이져는 주어진 환경하에서 최적의 경로를 찾아줄 뿐임. 우리가 정의한 환경에 문제가 있다면 아무리 훌륭한 옵티마이져라도 좋은 액세스를 찾아줄 수 없음.
- 조인의 순서에 매우 중요한 영향을 미치는 또 하나의 요소는 조인의 성공률.
- 두 개의 집합을 조인할 때는 보다 많은 처리범위를 줄여주는 집합이 선행되는 것만 중요하지만 세 개 이상의 테이블을 조인할 때는 각 조인 단계의 성공률은 다음 단계의 조인량을 결정.

p547 참조)  
인덱스를 스캔한 개수보다 테이블을 액세스한 숫자가 적다는 것은 인덱스 내부에서 체크하여 걸러진 것. 비효율 발생.  
결론적으로 조인에 최종적으로 성공한 건 124개. DEPT에 부여한 LOCATION으로 인한 것.  


- 논리적으로 가장 이상적인 처리방법은 가장 많은 데이터를 가진 테이블을 가장 먼저 최소의 범위로 만드는 일.    
- 하지만 실적에서는 이러한 판단을 내리는 것이 쉽지 않음. 복잡한 조인문인 경우 실행 계획도 길고 SQL도 복잡함. 이론적 배경을 바탕으로 많은 경우 대한 훈련이 필요.
- 지금까지 처리된 집합의 결과를 조인하고자 하는 집합에 결과를 제공했을 때 그것을 받는 것이 훨씬 유리하다면 Nested Loops, 그렇지 않으면 Sort Merge나 해쉬조인으로 해당 조인을 유도.
- 최적의 처리 경로를 알고 있어도 실행계획을 그렇게 나타나도록 유도하는 것은 쉽지 않음.
- 적절한 힌트를 잘 조합하거나, 인라인뷰를 이용하거나, 특정 컬럼의 인덱스 사용 억제(Suppressing)을 활용. 그렇도 안되면 ROWNUM을 삽입하여 특정 인라인뷰가 먼저 수행되도록 조정.

### 2.3.2 Sort Merge 조인

- 조인할 집합의 대응되는 대상은 서로 알 수 없는 임의의 장소이 위치할 때 이를 연결 가능하게 하는 방법은 서로 사전 작업을 통해 연결할 수 있는 모습으로 다시 배치하는 것.
- 재배치를 정렬(Sort) 방식으로 하여, 이들을 서로 연결(Merge)하는 방식이 Sort Merge.  

p554. 그림 2-2-16 참조)  
각 테이블에 범위 좁혀서 Sort해놓은 뒤 Merge.  
머지랑 정렬된 양쪽 값을 서로 비교하며 스캔해 내려가다가 다른 쪽 값이 비교할 값보다 커지면 멈추고, 그 커진 값과 반대편 값을 비교하여 다시 내려가는 방식.  
이 방식은 정렬해 둔 결과를 스캔하면서 연결되므로 연결작업에는 랜덤 액세스가 일어나지 않음.  
사용된 인덱스를 살펴보면 TAB1은 FLD1인덱스만 사용되었고, TAB2는 COL1인덱스만 사용. 연결고리인 KEY1, KEY2의 인덱스는 전혀 사용되지 않고 머지의 조건으로만 사용됨.  

#### 가) Sort Merge 조인의 특성
1. 동시적으로 처리됨. 양쪽 집합이 모두 준비완료 되어야만 머지를 시작할 수 있으므로 순차적인 처리가 불가능(동시적)
2. 각 집합이 준비작업을 할 때 다른 집합에서 처리한 결과를 제공받지 않음(독립적)
3. 정렬 준비가 완료된 후에라야 조인을 시작. 부분범위처리를 할 수 없어 항상 전체범위처리(전체범위처리)
4. 주로 스캔방식으로 처리. 처리범위를 줄이기 위해 인덱스를 사용하는 경우만 랜덤 액세스 발생(스캔방식)
5. 연결고리가 되는 컬럼은 인덱스를 전혀 사용하지 않음(선택적)
6. 조인의 방향과는 거의 무관(무방향성)
7. 스스로 자신의 처리범위를 줄이기 위해 사용되는 인덱스는 대개 가장 유리한 한 가지만 사용. 그 외의 조건들은 머지할 작업대상을 줄요주므로 중요

#### 나) Sort Merge 조인의 적용기준
1. 어차피 전체범위 처리를 할 수 밖에 없는 프로세싱에 검토
2. 상대방 테이블에서 어떤 상수값을 받지 않고서도 충분히 처리범위를 줄일 수 있다면 상당한 효과 기대
3. 주로 처리량이 많으면서 항상 전체범위 처리를 해야하는 경우에 유리
4. 연결고리 이상 상태에 영향을 받지 않으므로 연결고리를 위한 인덱스를 생성할 필요가 없을 때 매우 유용
5. 스스로 자신의 처리범위를 어떻게 줄일 수 있느냐가 수행속도에 많은 영향을 미치므로 효율적인 인덱스 구성이 중요
6. 전체범위처리를 하므로 운반단위의 크기가 수행속도에 영향을 미치지 않음.
7. 처리할 데이터 량이 적은 오란인 애플리케이션에서는 Nested Loops 조인이 더 유리
8. 옵티마이져 목표가 ALL_ROWS 인 경우 자주 Sort Merge 조인이나 해쉬조인으로 실행계획이 수립. 옵티마이져 목표에 주의.
9. 충분한 메모리 활용이 가능하고, 병렬처리를 통해 빠르게 정렬작업을 할 수 있다면 대량의 데이터 조인에 매우 유용.

### 2.3.3 Nested Loops 조인과 Sort Merge 조인의 비교
p559 참조)  
조건이 삭제되었을때 Nested Loops는 순차적으로 처리되므로 영향을 크게 받지 않으나, Sort Merge는 TAB2에 FULL SCAN이 일어남.  
뿐만 아니라 부담이 되는 정렬의 범위가 크게 늘어났고, 머지할 양도 크게 증가.  
이처럼 상황에 따라 조인 방식이 커다란 차이를 가져올 수 있음.

p561~562 참조)  
상수 조건 없어지고, order by 추가된 상황. Nested Loops는 상수를 받을 수 없으므로 FULL TABLE SCAN 발생 후 단계적으로 수행됨.  
Sort Merge 조인은 각각의 테이블마다 스캔 후 머지가 일어나므로 대량의 랜덤 액세스를 피할 수 있으므로 유리함.

### 2.3.4 해쉬(Hash) 조인
- 주로 소량의 특정 범위를 조인하는 용도로 활용하는 Nested Loops 조인은 처리범위만 지나치게 넓지 않다면 간단한 방법만으로 충분히 해결가능.
- 대량의 범위를 처리할 때는 상황이 어려움. Sort Merge 방식으로도 해결이 어려운 경우 시스템에 중대한 문제가 될 수 있음.
- 데이터 처리 범위가 초대향으로 증가하면서 Sort Merge가 더이상의 대안이 될 수 없는 지경에 이르렀음.
- 해쉬 조인은 연결행위마다 인덱스를 경유하여 랜덤을 하지 않고 해쉬 함수를 이용한 연결을 한다는 점과 파티션 단위로 처리하기 때문에 대량의 처리에도 수행속도가 급격히 상승하지 않는다.

#### ▷해쉬 영역(Hash Area)
- 해쉬 영역이란 해쉬 조인을 수행하기 위해 메모리 내에 만들어진 영역.  
- 해쉬 테이블에는 파티션들의 위치정보(Address)를 가지고 있으며 조인의 연결 작업을 수행할 때나 디스크에 내려가 있는 파티션 짝들을 찾는데 사용.

#### ▷파티션(Partition)
- 파티션이란 파티션을 결정하기 위해 수행하는 첫 번째 해쉬함수가 리턴한 동일한 해쉬값을 갖는 묶음.
- 동일한 해쉬값을 가진 로우들의 버켓(Bucket)
- 파티션 수를 많게 하면 적은 크기의 많은 파티션이 생성되기 때문에 비효율적인 I/O 발생할 수 있음.
- 반대로 너무 적게 하면 지나치게 큰 파티션이 생성되어 해쉬영역과 맞지 않을 수도 있음.

#### ▷클러스터(Cluster)
- 파티션은 작지않은 크기로 되어 있기 때문에 이를 다시 클러스터 단위로 분할.
- 클러스터는 연속된 블록으로 되어 있으며 디스크와 I/O하는 단위.
- 클러스터를 슬롯(Slot)이라고도 부르며, 마치 캐비닛을 파티션이라고 한다면 슬롯은 서랍에 비유가능.

#### ▷빌드 입력(Build Input)과 검색 입력(Probe Input)
- 조인을 위해 먼저 액세스하여 필요한 준비를 해두는 처리를 빌드입력.
- 나중에 액세스 하면서 조인을 수행하는 처리를 검증 혹은 검색입력.

#### ▷인-메모리(In-memory)해쉬조인과 유예 해쉬조인
- 빌드입력이 해쉬 영역에 모두 위치할 수 있는 경우는 인-메모리 해쉬 조인을 수행.
- 그렇지 못한 경우 유예 해쉬조인 수행.

#### ▷비트맵 벡터(Bitmap Vector)
- 빌드입력에 대해 파티션을 구하는 작업 중에 생성되며, 빌드 입력값들에 대한 유일한 값을 메모리 내의 해쉬 영역에 정의하는 것.
- 검색 입력의 파티션 생성 작업시에 필터링을 하는데 사용.

#### ▷해쉬 테이블(Hash Table)
- 이 테이블은 메모리 내에 만들어지며, 최종적으로 조인의 연결작업에서 대응되는 로우를 찾기 위한 해쉬 인덱스로 사용.
- 일반 인덱스에서 인덱스 컬럼값과 ROWID를 가지고 있는 것과 유사하게 해쉬 테이블은 해쉬키값과 해쉬 클러스터의 주소를 가지고 있음.

#### ▷파티션 테이블(Partition Table)
- 만약 빌드 입력이 메모리 크기를 초과하여 파티션을 생성하게 되면 파티션 테이블에 관련정보가 저장됨.

### 2.3.4.1 인-메모리 해쉬조인
- 인-메모리 해쉬조인은 빌드입력을 모두 메모리에 저장하고 해쉬 테이블을 만들어 검색 입력을 스캔하면서 조인을 수행
- 모양상으로는 랜덤이지만 거의 부담이 없는 램덤을 수행하기 때문에 Sort Merge처럼 연결을 위해 정령을 해야하거나 Nested Loops 처럼 수많은 블록을 액세스하지 않아도 되므로 대용량 데이터 조인에 매우 효과적.
- 특징은 조인의 연결을 위해서 기존에 미리 생성되어 있는 인덱스를 전혀 사용하지 않음.
- 조인 연결고리에 인덱스가 없어도 영향을 받지 않는다는 것과 그러면서도 오히려 기존의 B-Tree 인덱스 보다 더 유리한 해쉬를 이용한 조인을 할 수 있음.
- 다른 특징은 부분범위 처리가 가능.
- 그러나 메모리는 여러 프로세스들이 공동으로 사용하는 영역이라 크게 적용이 불가하므로 Nested Loop 조인으로 확실한 효율과 수행속도를 보장받을 수 있다면 지나치게 적용하지 않는 것이 좋음.

### 유예 해쉬조인
- 빌드입력이 해쉬영역을 초과하게 되면 어쩔 수 없이 디스크에 저장해야함.
- 빌드 입력의 일부라도 디스크에 저장할 수 밖에 없다면 정렬을 통해 연결을 하는 Sort Merge 조인처럼 정렬과 유사한 효과를 얻을 수 있는 방법이 해슁함수를 이용하는 방법.
- 해쉬영역을 초과하는 대용량의 데이터라 하더라도 해쉬함수를 이용하여 적절한 위치에 옮겨 두었다가 조인대상들을 다시 불러들여 해쉬 테이블을 통해 조인을 수행하므로 Sort Merge 조인이 갖는 최대의 약점인 대용량 데이터의 정렬에 대한 오버헤드를 해결.
- 선행 처리된 집합이 만든 비트맵 벡터를 이용하여 나중에 처리되는 집합을 조인 전에 미리 필터링을 할 수 있으므로 Nested Loops의 장점도 가짐.

## 민선유 : 580 ~ 634 (2부 2.3.8절)
